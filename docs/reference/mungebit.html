<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Run a mungebit. — mungebit_run • mungebits2</title>

<!-- jquery -->
<script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">


<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script>
<script src="../pkgdown.js"></script>

<!-- mathjax -->
<script src='https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->


  </head>

  <body>
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">mungebits2</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
      
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      
      </header>

      <div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Run a mungebit.</h1>
    </div>

    
    <p>Imagine flipping a switch on a set of train tracks. A mungebit
behaves like this: once the <code>trained</code> switch is flipped,
it can only run the <code>predict_function</code>, otherwise it will
run the <code>train_function</code>.</p>
<p>The train function is responsible for performing a munging step and
storing metadata that can replicate the munging step in a live
production environment without the full reference data set.</p>
<p>The predict function is responsible for performing a munging step
using metadata it computed during an earlier training step.
This is usually done in a live production environment setting.</p>
<p>The majority of data projects are overcome by the burden of excessive
data wrangling. Part of the problem lies in the fact that when new
data is introduced that was drawn from the same source as the original,
such as a training set for a statistical model, <em>different</em> code
needs to be written to achieve the same transformations. Mungebits solve
this problem by forcing the user to determine how to correctly munge
on out-of-sample data (such as live streaming data in the form of one-row
data.frames) at "munge-time", when the reason for the wrangling is still
apparent. A frequent source of data errors is treating this process as an
afterthought.</p>
    

    <pre class="usage"><span class='fu'>mungebit_run</span>(<span class='no'>data</span>, <span class='no'>...</span>)

<span class='fu'>mungebit_train</span>(<span class='no'>data</span>, <span class='no'>...</span>, <span class='kw'>`_envir`</span> <span class='kw'>=</span> <span class='fu'>parent.frame</span>())

<span class='fu'>mungebit_predict</span>(<span class='no'>data</span>, <span class='no'>...</span>, <span class='kw'>`_envir`</span> <span class='kw'>=</span> <span class='fu'>parent.frame</span>())

<span class='no'>mungebit</span></pre>
    
    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a> Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>data</th>
      <td><p>environment or data.frame. Essentially an environment
containing a <code>data</code> variable. In this case, that <code>data</code> variable
will have a side effect enacted on it. If a <code>data.frame</code>, then 
the return value will be the modified <code>data.frame</code> and the mungebit
will record any results it must memorize in its <code>input</code>.</p></td>
    </tr>
    <tr>
      <th>...</th>
      <td><p>additional arguments to the mungebit's <code>train_function</code> or
<code>predict_function</code>.</p></td>
    </tr>
    <tr>
      <th>_envir</th>
      <td><p>environment. Internal argument used for determining
the execution context of the invoked <code>train_function</code> or
<code>predict_function</code>.</p></td>
    </tr>
    </table>
    
    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>The modified <code>data</code>, whether it is an <code>environment</code>
  or <code>data.frame</code>.</p>
<p>The modified <code>data</code>, whether it is an <code>environment</code>
  or <code>data.frame</code>. Side effects on the <code>input</code> local variable
  provided to the <code>train_function</code> will be recorded on the mungebit
  object.</p>
<p>The modified <code>data</code>, whether it is an <code>environment</code>
  or <code>data.frame</code>. Side effects on the <code>input</code> local variable
  provided to the <code>predict_function</code> will be recorded on the mungebit
  object.</p>
    
    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>The purpose of the train function is to</p><ol>
<li><p>Perform some munging on the data set, such as renaming
    columns, creating derived features, performing principal component
    analysis, replacing some values, removing outliers, etc.</p></li>
<li><p>Storing the metadata necessary to replicate the munging operation
    after the original training set is no longer available. For example,
    if we are imputing a variable, we would need to remember its mean
    so we can use it later to replace <code>NA</code> values.</p></li>
</ol>
    <p>The purpose of the predict function is to</p><ol>
<li><p>Perform some munging on the data set, such as renaming
    columns, creating derived features, performing principal component
    analysis, replacing some values, removing outliers, etc.</p></li>
<li><p>Use the metadata computed during the <code>train</code> step
   to correctly perform this munging.</p></li>
</ol>
    <p>Consider the following problem. Imagine we wish to discretize a variable,
say determined algorithmically with cuts [0, 0.5), [0.5, 1.5), [1.5, 3).
When we apply the same transformation on a new data set, we cannot run
the same discretization code, since it may produce new cutoffs, and hence
invalidate the results if, for example, we had trained a model on the
prior cutoffs. To ensure the exact same mathematical transformation
is performed on new data--whether a new test set derived from recent
data or a one-row data.frame representing a single record streaming
through a production system--we must run <em>different code</em> on
the "original" set versus the new set.</p>
<p>Mathematically speaking, a transformation of a data set can be represented
by a single mathematical function that is implemented differently during
"training" versus "prediction." Here, "training" refers to the first
time the transformation is performed, and "prediction" refers to 
subsequent times, such as on newly obtained data or a one-row data.frame
representing a single new record in a production system.</p>
<p>Therefore, the <em>correct</em> approach to data preparation, if you
wish to re-use it in the future on new data sets or in a live production
environment, is to treat it as a collection of tuples
<code>(train_function, predict_function, input)</code>, where
<code>train_function</code> represents the original code, <code>input</code> represents
an arbitrary R object such as a list, used for storing "metadata"
necessary to re-create the original transformation, and the
<code>predict_function</code> takes this <code>input</code> metadata and produces
the identical transformation on an out-of-sample data set.</p>
<p>For example, if we wish to impute a data set, <code>train_function</code>
might compute the mean, store it in <code>input$mean</code>, replace
the <code>NA</code> values with the mean, and return the dataset. Meanwhile,
the <code>predict_function</code> simply replaces the <code>NA</code> values
with the cached <code>input$mean</code>.</p>
<p>Usually, these steps would be in disjoint code bases: the modeler
would perform the ad-hoc munging while playing with the dataset,
and a software engineer would take the computed <code>input$mean</code>
and hard code it into a "data pipeline". It would be infeasible
to recompute the mean on-the-fly since <em>it depends on the
original data set</em>, which may be prohibitively large. However,
while it may require a lot of space and time to compute the
original <code>input</code>, as they are parameterized potentially by
a very large data set, usually the <code>input</code> itself is small
and the resulting <code>predict_function</code> is inexpensive.</p>
<p>The fundamental problem of data preparation, and the reason why
<a href = 'http://www.nytimes.com/2014/08/18/technology/for-big-data-scientists-hurdle-to-insights-is-janitor-work.html'>data scientists spend over 90% of their time on data preparation</a>,
is a lack of respect for this dichotomy. Using mungebits makes
this duality blatantly apparent in all circumstances and will hopefully
reduce the amount of time wasted on cumbersome wrangling.</p>
    

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='fu'>not_run</span>({
  <span class='no'>mb</span> <span class='kw'>&lt;-</span> <span class='fu'>mungebit</span>(<span class='fu'><a href='column_transformation.html'>column_transformation</a></span>(<span class='kw'>function</span>(<span class='no'>col</span>, <span class='no'>scale</span> <span class='kw'>=</span> <span class='kw'>NULL</span>) {
    <span class='kw'>if</span> (!<span class='fu'>isTRUE</span>(<span class='no'>trained</span>)) { <span class='co'># trained is an injected keyword</span>
     <span class='fu'>cat</span>(<span class='st'>"Column scaled by "</span>, <span class='no'>input</span>$<span class='no'>scale</span>, <span class='st'>"\n"</span>)
    } <span class='kw'>else</span> {
     <span class='no'>input</span>$<span class='no'>scale</span> <span class='kw'>&lt;-</span> <span class='no'>scale</span>
    }

    <span class='no'>col</span> * <span class='no'>input</span>$<span class='no'>scale</span>
  }))

  <span class='no'>iris2</span> <span class='kw'>&lt;-</span> <span class='no'>mb</span>$<span class='fu'>run</span>(<span class='no'>iris</span>, <span class='st'>"Sepal.Length"</span>, <span class='fl'>2</span>)
  <span class='co'># iris2 now contains a copy of iris with Sepal.Length doubled.</span>
  <span class='no'>iris3</span> <span class='kw'>&lt;-</span> <span class='no'>mb</span>$<span class='fu'>run</span>(<span class='no'>iris2</span>, <span class='st'>"Sepal.Length"</span>)
  <span class='co'># &gt; Column scaled by 2</span>
  <span class='fu'>head</span>(<span class='no'>iris3</span><span class='kw'>[[</span><span class='fl'>1</span>]] / <span class='no'>iris</span><span class='kw'>[[</span><span class='fl'>1</span>]])
  <span class='co'># &gt; [1] 4 4 4 4 4 4 </span>
})</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2>Contents</h2>
    <ul class="nav nav-pills nav-stacked">
      <li><a href="#arguments">Arguments</a></li>
      
      <li><a href="#value">Value</a></li>

      <li><a href="#details">Details</a></li>
      
      <li><a href="#examples">Examples</a></li>
    </ul>

  </div>
</div>

      <footer>
      <div class="copyright">
  <p>Developed by Robert Krzyzanowski.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
   </div>

  </body>
</html>
